import { Query } from "./base";
import { Data } from "./data";
import { EventRegistry } from "./eventRegistry";
import { ReturnInfo } from "./returnInfo";
import { ER } from "./types";
/**
 * @class QueryEvents
 * Class for obtaining available info for one or more events in the Event Registry
 */
export declare class QueryEvents extends Query<RequestEvents> {
    params: {};
    constructor(args?: ER.QueryEvents.Arguments);
    get path(): string;
    /**
     * Set the single result type that you would like to be returned. Any previously set result types will be overwritten.
     * Result types can be the classes that extend RequestEvent base class (see classes below).
     */
    setRequestedResult(requestEvents: RequestEvents): void;
    /**
     * Set a custom list of event uris. The results will be then computed on this list - no query will be done (all conditions will be ignored).
     */
    static initWithEventUriList(uriList: string[]): QueryEvents;
    /**
     * Set a custom list of event uris. The results will be then computed on this list - no query will be done (all conditions will be ignored).
     */
    static initWithEventUriWgtList(...args: any[]): any;
    static initWithComplexQuery(...args: any[]): any;
}
/**
 * @class QueryEventsIter
 * Class for iterating through all the events via callbacks
 */
export declare class QueryEventsIter extends QueryEvents implements AsyncIterable<Data.Event> {
    private readonly er;
    private readonly sortBy;
    private readonly sortByAsc;
    private readonly returnInfo;
    private readonly maxItems;
    private page;
    private pages;
    private items;
    private returnedSoFar;
    private index;
    private callback;
    private doneCallback;
    private errorMessage;
    constructor(er: EventRegistry, args?: ER.QueryEvents.IteratorArguments);
    /**
     * Async Iterator function that returns the next item in the list of events
     */
    [Symbol.asyncIterator](): AsyncIterator<Data.Event>;
    count(): Promise<number>;
    /**
     * Execute query and fetch batches of events of the specified size (eventBatchSize)
     * @param callback callback function that'll be called every time we get a new batch of events from the backend
     * @param doneCallback callback function that'll be called when everything is complete
     */
    execQuery(callback: (item: Data.Event) => void, doneCallback?: (error?: string) => void): void;
    static initWithComplexQuery(er: any, complexQuery: any, args?: ER.QueryEvents.IteratorArguments): QueryEventsIter;
    private iterate;
    /**
     * Extract the results according to maxItems
     * @param response response from the backend
     */
    private extractResults;
    private get current();
    private getNextBatch;
}
export declare class RequestEvents {
}
/**
 * @class RequestEventsInfo
 * Return event details for resulting events.
 */
export declare class RequestEventsInfo extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsInfoArguments);
}
/**
 * @class RequestEventsUriList
 * Return a simple list of event uris together with the scores for resulting events.
 */
export declare class RequestEventsUriWgtList extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsUriWgtListArguments);
    set page(page: number);
}
/**
 * @class RequestEventsTimeAggr
 * Return time distribution of resulting events.
 */
export declare class RequestEventsTimeAggr extends RequestEvents {
    resultType: string;
}
/**
 * Return keyword aggregate (tag cloud) on words in articles in resulting events.
 * @class RequestEventsTimeAggr
 */
export declare class RequestEventsKeywordAggr extends RequestEvents {
    resultType: string;
    params: any;
    /**
     * @param lang: in which language to produce the list of top keywords. If undefined, then compute on all articles
     */
    constructor(lang?: any);
}
/**
 * @class RequestEventsLocAggr
 * Return aggregate of locations of resulting events.
 */
export declare class RequestEventsLocAggr extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsLocAggrArguments);
}
/**
 * @class RequestEventsLocTimeAggr
 * Return aggregate of locations and times of resulting events.
 */
export declare class RequestEventsLocTimeAggr extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsLocTimeAggrArguments);
}
/**
 * @class RequestEventsConceptAggr
 * Compute which concept are the most frequently occurring in the list of resulting events.
 */
export declare class RequestEventsConceptAggr extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsConceptAggrArguments);
}
/**
 * @class RequestEventsConceptGraph
 * Compute which concept pairs frequently co-occur together in the resulting events.
 */
export declare class RequestEventsConceptGraph extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsConceptGraphArguments);
}
/**
 * @class RequestEventsConceptMatrix
 * Get a matrix of concepts and their dependencies.
 * For individual concept pairs return how frequently
 * they co-occur in the resulting events and how "surprising" this is,
 * based on the frequency of individual concepts.
 */
export declare class RequestEventsConceptMatrix extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsConceptMatrixArguments);
}
/**
 * @class RequestEventsConceptTrends
 * Return a list of top trending concepts and their daily trending info over time
 */
export declare class RequestEventsConceptTrends extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsConceptTrendsArguments);
}
/**
 * @class RequestEventsSourceAggr
 * Return top news sources that report about the events that match the search conditions
 */
export declare class RequestEventsSourceAggr extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsSourceAggrArguments);
}
/**
 * @class RequestEventsDateMentionAggr
 * Return events and the dates that are mentioned in articles about these events
 */
export declare class RequestEventsDateMentionAggr extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsDateMentionAggrArguments);
}
/**
 * @class RequestEventsEventClusters
 * Return hierarchical clustering of events into smaller clusters. 2-means clustering is applied on each node in the tree
 */
export declare class RequestEventsEventClusters extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsEventClustersArguments);
}
/**
 * @class RequestEventsCategoryAggr
 * Return distribution of events into dmoz categories.
 */
export declare class RequestEventsCategoryAggr extends RequestEvents {
    resultType: string;
    params: any;
    constructor(returnInfo?: ReturnInfo);
}
/**
 * @class RequestEventsRecentActivity
 * Return a list of recently changed events that match search conditions.
 */
export declare class RequestEventsRecentActivity extends RequestEvents {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsRecentActivityArguments);
}
