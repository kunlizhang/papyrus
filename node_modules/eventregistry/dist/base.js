"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.Query = exports.QueryParamsBase = exports.QueryItems = exports.allLangs = exports.mainLangs = void 0;
var moment = require("moment");
var logger_1 = require("./logger");
exports.mainLangs = ["eng", "deu", "zho", "slv", "spa"];
exports.allLangs = ["eng", "deu", "spa", "cat", "por", "ita", "fra", "rus", "ara", "tur", "zho", "slv", "hrv", "srp"];
// Utility classes for Event Registry
var QueryItems = /** @class */ (function () {
    function QueryItems(oper, items) {
        this.oper = oper;
        this.items = items;
    }
    QueryItems.prototype.getOper = function () {
        return this.oper;
    };
    QueryItems.prototype.getItems = function () {
        return this.items;
    };
    QueryItems.AND = function (items) { return new QueryItems("$and", items); };
    QueryItems.OR = function (items) { return new QueryItems("$or", items); };
    return QueryItems;
}());
exports.QueryItems = QueryItems;
/**
 * @class QueryParamsBase
 * Base class for Query and AdminQuery
 * used for storing parameters for a query. Parameter values can either be
 * simple values (set by setVal()) or an array of values (set by multiple
 * calls to addArrayVal() method)
 */
var QueryParamsBase = /** @class */ (function () {
    function QueryParamsBase() {
        this.params = {};
    }
    /**
     * Encode datetime into UTC ISO format which can be sent to ER.
     */
    QueryParamsBase.encodeDateTime = function (val, format) {
        var datetime = moment.utc(val);
        if (!datetime.isValid()) {
            throw new Error("Datetime was not recognizable. Use `new Date()` or string in ISO format");
        }
        return (format === null || format === undefined) ? datetime.toISOString() : datetime.format(format);
    };
    /**
     * Return the parameters.
     */
    QueryParamsBase.prototype.getQueryParams = function () {
        return this.params;
    };
    /**
     * Set a value of a property in the query.
     */
    QueryParamsBase.prototype.setVal = function (key, value) {
        this.params[key] = value;
    };
    /**
     * Do we have in the query property named 'key'?
     */
    QueryParamsBase.prototype.hasVal = function (key) {
        return this.params.hasOwnProperty(key);
    };
    /**
     * Remove the value of a property key (if existing).
     */
    QueryParamsBase.prototype.clearVal = function (key) {
        delete this.params[key];
    };
    /**
     * Add a value to an array of values for a property.
     */
    QueryParamsBase.prototype.addArrayVal = function (key, val) {
        this.params[key] = __spreadArray(__spreadArray([], __read((this.params[key] || [])), false), [val], false);
    };
    /**
     * Set value in query params if the 'val' is different from 'defVal'.
     */
    QueryParamsBase.prototype.setValIfNotDefault = function (propName, val, defVal) {
        if (val !== defVal) {
            this.setVal(propName, val);
        }
    };
    /**
     * Set a property value that represents date.
     * Value can be string in YYYY-MM-DD format or a Date object.
     */
    QueryParamsBase.prototype.setDateVal = function (propName, val) {
        this.setVal(propName, QueryParamsBase.encodeDateTime(val, "YYYY-MM-DD"));
    };
    /**
     * Parse the value "value" and use it to set the property propName and the operator with name propOperName
     * @param value String, QueryItems or an array.
     * @param propName Values to be set using property name propName.
     * @param propOperName Property to set containing the "and" or "or". Relevant only if multiple items are provided in "value". Can be None if only one value is possible.
     * @param defaultOperName Which operator should be used in case "value" is an array. If an array, we will print also a warning to suggest use of QueryItems.
     */
    QueryParamsBase.prototype.setQueryArrVal = function (value, propName, propOperName, defaultOperName) {
        if (!value) {
            return;
        }
        if (value instanceof QueryItems) {
            this.params[propName] = value.getItems();
            var formattedOperator = value.getOper().replace(/\$/g, "");
            if (propOperName) {
                this.params[propOperName] = formattedOperator;
            }
            if (propOperName === undefined && formattedOperator !== defaultOperName) {
                throw new Error("An invalid operator type '".concat(formattedOperator, "' was used for property '").concat(propName, "'"));
            }
        }
        else if (typeof value === "string") {
            this.params[propName] = value;
        }
        else if (Array.isArray(value)) {
            this.params[propName] = value;
            if (propOperName !== undefined) {
                this.params[propOperName] = defaultOperName;
                if (value.length > 1) {
                    logger_1.Logger.warn("\n                        Warning: The value of parameter '".concat(propName, "' was provided as a list and '").concat(defaultOperName, "' operator was used implicitly between the items.\n                        We suggest specifying the list using the QueryItems.AND() or QueryItems.OR() to ensure the appropriate operator is used.\n                    "));
                }
            }
        }
        else {
            throw new Error("Parameter '".concat(propName, "' was of unsupported type. It should either be None, a string or an instance of QueryItems"));
        }
    };
    return QueryParamsBase;
}());
exports.QueryParamsBase = QueryParamsBase;
var Query = /** @class */ (function (_super) {
    __extends(Query, _super);
    function Query() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.params = {};
        return _this;
    }
    Object.defineProperty(Query.prototype, "path", {
        get: function () {
            return this.internalPath;
        },
        set: function (path) {
            this.internalPath = path;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Prepare the request parameters
     */
    Query.prototype.getQueryParams = function () {
        var e_1, _a;
        if (this.resultTypeList.length === 0) {
            throw new Error("The query does not have any result type specified. No sense in performing such a query");
        }
        var allParams = this.params;
        try {
            for (var _b = __values(this.resultTypeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var resultType = _c.value;
                allParams = __assign(__assign({}, allParams), resultType === null || resultType === void 0 ? void 0 : resultType.params);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var formattedResultTypeList = this.getFormattedResultTypeList();
        if ((formattedResultTypeList === null || formattedResultTypeList === void 0 ? void 0 : formattedResultTypeList.length) > 0) {
            allParams = __assign(__assign({}, allParams), { resultType: formattedResultTypeList });
        }
        return JSON.parse(JSON.stringify(allParams));
    };
    Query.prototype.getFormattedResultTypeList = function () {
        var _a;
        if (!this.resultTypeList.every(function (result) { return (result === null || result === void 0 ? void 0 : result.resultType) !== undefined; })) {
            return [];
        }
        if (this.resultTypeList.length === 1) {
            return (_a = this.resultTypeList[0]) === null || _a === void 0 ? void 0 : _a.resultType;
        }
        else {
            return this.resultTypeList.map(function (result) { return result === null || result === void 0 ? void 0 : result.resultType; });
        }
    };
    return Query;
}(QueryParamsBase));
exports.Query = Query;
/**
 * Utility function used in conjunction with a async/await and/or Promise
 */
function sleep(ms) {
    return new Promise(function (resolve) {
        setTimeout(resolve, ms);
    });
}
exports.sleep = sleep;
//# sourceMappingURL=base.js.map