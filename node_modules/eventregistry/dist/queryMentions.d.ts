import { Query } from "./base";
import { EventRegistry } from "./eventRegistry";
import { ER } from "./types";
export declare class QueryMentions extends Query<RequestMentions> {
    params: {};
    constructor(args?: ER.QueryMentions.Arguments);
    get path(): string;
    /**
     * Set the single result type that you would like to be returned. Any previously set result types will be overwritten.
     * Result types can be the classes that extend RequestMentions base class (see classes below).
     */
    setRequestedResult(requestMentions: RequestMentions): void;
    static initWithMentionUriList(...args: any[]): any;
    static initWithMentionUriWgtList(...args: any[]): any;
    static initWithComplexQuery(...args: any[]): any;
}
export declare class QueryMentionsIter extends QueryMentions implements AsyncIterable<Record<string, any>> {
    private readonly er;
    private readonly sortBy;
    private readonly sortByAsc;
    private readonly returnInfo;
    private readonly maxItems;
    private page;
    private pages;
    private items;
    private returnedSoFar;
    private index;
    private callback;
    private doneCallback;
    private errorMessage;
    constructor(er: EventRegistry, args?: ER.QueryMentions.IteratorArguments);
    [Symbol.asyncIterator](): AsyncIterator<Record<string, any>>;
    count(): Promise<number>;
    /**
     * Execute query and fetch batches of articles of the specified size (eventBatchSize)
     * @param callback callback function that'll be called every time we get a new batch of events from the backend
     * @param doneCallback callback function that'll be called when everything is complete
     */
    execQuery(callback: (item: any) => void, doneCallback?: (error?: any) => void): void;
    static initWithComplexQuery(er: any, complexQuery: any, args?: ER.QueryMentions.IteratorArguments): QueryMentionsIter;
    private iterate;
    /**
     * Extract the results according to maxItems
     * @param response response from the backend
     */
    private extractResults;
    private get current();
    private getNextBatch;
}
export declare class RequestMentions {
}
export declare class RequestMentionsInfo extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryEvents.RequestEventsInfoArguments);
    set page(page: number);
}
export declare class RequestMentionsUriWgtList extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsUriWgtListArguments);
    set page(page: any);
}
export declare class RequestMentionsTimeAggr extends RequestMentions {
    resultType: string;
}
export declare class RequestMentionsConceptAggr extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsConceptAggrArguments);
}
export declare class RequestMentionsCategoryAggr extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsCategoryAggrArguments);
}
export declare class RequestMentionsSourceAggr extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsSourceAggrArguments);
}
export declare class RequestMentionsKeywordAggr extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsKeywordAggrArguments);
}
export declare class RequestMentionsConceptGraph extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsConceptGraphArguments);
}
export declare class RequestMentionsRecentActivity extends RequestMentions {
    resultType: string;
    params: any;
    constructor(args?: ER.QueryMentions.RequestMentionsRecentActivityArguments);
}
