import { AxiosResponse } from "axios";
import { ReturnInfo } from "./returnInfo";
import { ER } from "./types";
import { QueryArticle } from "./queryArticle";
import { QueryArticles } from "./queryArticles";
import { QueryEvents } from "./queryEvents";
import { QueryEvent } from "./queryEvent";
import { Logger } from "./logger";
/**
 * @class EventRegistry
 * Main class responsible for obtaining results form the Event Registry
 */
export declare class EventRegistry {
    logger: Logger;
    private config;
    private headers;
    private dailyAvailableRequests;
    private remainingAvailableRequests;
    private lastQueryTime;
    private _logRequests;
    private readonly lock;
    private readonly stopStatusCodes;
    constructor(config?: ER.Config);
    /**
     * Should all requests be logged to a file or not?
     */
    setLogging(logging: boolean): void;
    get allowUseOfArchive(): boolean;
    get verboseOutput(): boolean;
    /**
     * Main method for executing the search queries.
     * @param query instance of Query class
     */
    execQuery<T = ER.SuccessfulResponse<unknown>>(query: any, allowUseOfArchive?: boolean): Promise<ER.Response<T>>;
    jsonRequestAnalytics<T = unknown>(path: string, parameters?: any, headers?: any, cookies?: any): Promise<AxiosResponse<T>>;
    /**
     * Make a request for json data
     * @param path url on er (e.g. "/api/v1/article")
     * @param parameters Optional parameters to be included in the request
     */
    jsonRequest<T = unknown>(path: string, parameters?: any, allowUseOfArchive?: boolean): Promise<AxiosResponse<T>>;
    /**
     * get the number of requests that are still available for the user today. Information is only accessible after you make some query.
     */
    getRemainingAvailableRequests(): number;
    /**
     * get the total number of requests that the user can make in a day. Information is only accessible after you make some query.
     */
    getDailyAvailableRequests(): number;
    /**
     * Return the headers returned in the response object of the last executed request
     */
    getLastHeaders(): {};
    /**
     * Get a value of the header headerName that was set in the headers in the last response object
     */
    getLastHeader(headerName: string, dfltVal?: string): any;
    /**
     * print some statistics about the last executed request
     */
    printLastReqStats(): void;
    /**
     * return true or false depending on whether the last request used the archive or not
     */
    getLastReqArchiveUse(): boolean;
    /**
     * Return the number of used and total available tokens. Can be used at any time (also before making queries)
     */
    getUsageInfo(): Promise<ER.UsageInfo>;
    getServiceStatus(): Promise<ER.UsageInfo>;
    getUrl(query: QueryArticles | QueryArticle | QueryEvents | QueryEvent): string;
    /**
     * Return a list of concepts that contain the given prefix.
     * Returned matching concepts are sorted based on their frequency of occurrence in news (from most to least frequent)
     * @param prefix input text that should be contained in the concept
     * @param args Object which contains a host of optional parameters
     */
    suggestConcepts(prefix: string, args?: ER.SuggestConceptsArguments): Promise<unknown>;
    /**
     * Return a list of dmoz categories that contain the prefix
     * @param prefix input text that should be contained in the category name
     * @param args Object which contains a host of optional parameters
     */
    suggestCategories(prefix: string, args?: ER.SuggestCategoriesArguments): Promise<unknown>;
    /**
     * Return a list of news sources that match the prefix
     * @param prefix input text that should be contained in the source name or uri
     * @param args Object which contains a host of optional parameters
     */
    suggestNewsSources(prefix: string, args?: ER.SuggestNewsSourcesArguments): Promise<unknown>;
    /**
     * Return a list of news source groups that match the prefix
     * @param prefix input text that should be contained in the source group name or uri
     * @param args Object which contains a host of optional parameters
     */
    suggestSourceGroups(prefix: string, args?: ER.SuggestSourceGroupsArguments): Promise<unknown>;
    /**
     * Return a list of geo locations (cities or countries) that contain the prefix
     * @param prefix input text that should be contained in the location name
     * @param args Object which contains a host of optional parameters
     */
    suggestLocations(prefix: string, args?: ER.SuggestLocationsArguments): Promise<ER.Location[]>;
    /**
     * Return a list of geo locations (cities or places) that are close to the provided (lat, long) values
     * @param latitude latitude part of the coordinate
     * @param longitude longitude part of the coordinate
     * @param radiusKm radius in kilometers around the coordinates inside which the locations should be returned
     * @param args Object which contains a host of optional parameters
     */
    suggestLocationsAtCoordinate(latitude: number, longitude: number, radiusKm: number, args?: ER.SuggestLocationsAtCoordinateArguments): Promise<unknown>;
    /**
     * Return a list of news sources that are close to the provided (lat, long) values
     * @param latitude latitude part of the coordinate
     * @param longitude longitude part of the coordinate
     * @param radiusKm radius in kilometers around the coordinates inside which the news sources should be located
     * @param count number of returned suggestions
     */
    suggestSourcesAtCoordinate(latitude: number, longitude: number, radiusKm: number, count?: number, ...otherParams: any[]): Promise<unknown>;
    /**
     * Return a list of news sources that are close to the provided (lat, long) values
     * @param conceptUri concept that represents a geographic location for which we would like to obtain a list of sources located at the place
     * @param args Object which contains a host of optional parameters
     */
    suggestSourcesAtPlace(conceptUri: string, args?: ER.SuggestSourcesAtPlaceArguments): Promise<unknown>;
    /**
     * Return a list of news sources that match the prefix
     * @param prefix: input text that should be contained in the author name and source url
     * @param page: page of results
     * @param count: number of returned suggestions
     */
    suggestAuthors(prefix: string, page?: number, count?: number, ...otherParams: any[]): Promise<unknown>;
    /**
     * Return a list of event types that match the prefix
     * @param prefix: input text that should be contained in the industry name
     * @param page: page of results
     * @param count: number of returned suggestions
     */
    suggestEventTypes(prefix: string, page?: number, count?: number, ...otherParams: any[]): Promise<unknown>;
    /**
     * Return a list of industries that match the prefix. Note: Industries can only be used when querying mentions (QueryMentions, QueryMentionsIter)
     * @param prefix: input text that should be contained in the industry name
     * @param page: page of results
     * @param count: number of returned suggestions
    */
    suggestIndustries(prefix: string, page?: number, count?: number, ...otherParams: any[]): Promise<unknown>;
    /**
     * Return a list of SDG uris. Note: Industries can only be used when querying mentions (QueryMentions, QueryMentionsIter)
     */
    getSdgUris(): Promise<unknown>;
    /**
     * Return a list of SASB uris. Note: SASB uris can only be used when querying mentions (QueryMentions, QueryMentionsIter)
     */
    getSasbUris(): Promise<unknown>;
    /**
     * Return a list of concept classes that match the given prefix
     * @param prefix input text that should be contained in the category name
     * @param args Object which contains a host of optional parameters
     */
    suggestConceptClasses(prefix: string, args?: ER.SuggestConceptClassesArguments): Promise<unknown>;
    /**
     * return a concept uri that is the best match for the given concept label
     * if there are multiple matches for the given conceptLabel,
     * they are sorted based on their frequency of occurrence in news (most to least frequent)
     * @param conceptLabel partial or full name of the concept for which to return the concept uri
     * @param args Object which contains a host of optional parameters
     */
    getConceptUri(conceptLabel: string, args?: ER.GetConceptUriArguments): Promise<any>;
    /**
     * Return a location uri that is the best match for the given location label
     * @param locationLabel partial or full location name for which to return the location uri
     * @param args Object which contains a host of optional parameters
     */
    getLocationUri(locationLabel: string, args?: ER.GetLocationUriArguments): Promise<string>;
    /**
     * Return a category uri that is the best match for the given label
     * @param categoryLabel partial or full name of the category for which to return category uri
     */
    getCategoryUri(categoryLabel: string): Promise<any>;
    /**
     * Return the news source that best matches the source name
     * @param sourceName partial or full name of the source or source uri for which to return source uri
     * @param dataType: return the source uri that provides content of these data types
     */
    getNewsSourceUri(sourceName: string, dataType?: ER.DataType[] | ER.DataType): Promise<any>;
    /**
     * alternative (shorter) name for the method getNewsSourceUri()
     */
    getSourceUri(sourceName: string, dataType?: ER.DataType[] | ER.DataType): Promise<any>;
    /**
     * Return the URI of the source group that best matches the name
     * @param sourceGroupName partial or full name of the source group
     */
    getSourceGroupUri(sourceGroupName: string): Promise<any>;
    /**
     * Return a uri of the concept class that is the best match for the given label
     * @param classLabel partial or full name of the concept class for which to return class uri
     * @param lang language in which the class label is specified
     */
    getConceptClassUri(classLabel: string, lang?: string): Promise<any>;
    /**
     * Return detailed information about a particular concept
     * @param conceptUri uri of the concept
     * @param returnInfo what details about the concept should be included in the returned information
     */
    getConceptInfo(conceptUri: string, returnInfo?: ReturnInfo): Promise<unknown>;
    /**
     * return author uri that is the best match for the given author name (and potentially source url)
     * if there are multiple matches for the given author name, they are sorted based on the number of articles they have written (from most to least frequent)
     * @param authorName: partial or full name of the author, potentially also containing the source url (e.g. "george brown nytimes")
     */
    getAuthorUri(authorName: string): Promise<any>;
    static getUriFromUriWgt(uriWgtList: string[]): string[];
    /**
     * If you have article urls and you want to query them in ER you first have to obtain their uris in the ER.
     * @param articleUrls a single article url or a list of article urls
     */
    getArticleUris(articleUrls: string | string[]): Promise<unknown>;
    /**
     * Return information about the latest imported article
     */
    getSourceGroups(): Promise<unknown>;
    /**
     * Return info about the source group
     */
    getSourceGroup(sourceGroupUri: string): Promise<unknown>;
}
/**
 * @class ArticleMapper
 * Create instance of article mapper it will map from article urls to article uris
 * the mappings can be remembered so it will not repeat requests for the same article urls
 */
export declare class ArticleMapper {
    private er;
    private articleUrlToUri;
    private rememberMappings;
    constructor(er: EventRegistry, rememberMapping?: boolean);
    /**
     * Given the article url, return an array with 0, 1 or more article uris.
     * Not all returned article uris are necessarily valid anymore.
     * For news sources of lower importance we remove the duplicated articles and just keep the latest content
     * @param articleUrl string containing the article url
     */
    getArticleUri(articleUrl: string): Promise<any>;
}
