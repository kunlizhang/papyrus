import { EventRegistry } from "./eventRegistry";
import { ER } from "./types";
export declare class Analytics {
    private er;
    /**
     * @param eventRegistry: instance of EventRegistry class
     */
    constructor(er: EventRegistry);
    /**
     * Identify the list of entities and nonentities mentioned in the text
     * @param text input text to annotate
     * @param lang language of the provided document (can be an ISO2 or ISO3 code). If None is provided, the language will be automatically detected
     */
    annotate(text: string, lang?: string[], customParams?: {
        [name: string]: unknown;
    }): Promise<ER.Analytics.Response.Annotate>;
    /**
     * Determine the set of up to 5 categories the text is about. Currently, only English text can be categorized!
     * @param text input text to categorize
     * @param taxonomy: which taxonomy use for categorization. Options:
     *  - "dmoz" (over 5000 categories in 3 levels, English language only)
     *  - "news" (general news categorization, 9 categories, any langauge)
     */
    categorize(text: string, taxonomy?: "dmoz" | "news"): Promise<ER.Analytics.Response.Categorize>;
    /**
     * determine the sentiment of the provided text in English language
     * @param text input text to categorize
     * @param method method to use to compute the sentiment. possible values are "vocabulary" (vocabulary based sentiment analysis) and "rnn" (neural network based sentiment classification)
     */
    sentiment(text: string, method?: string, sentences?: number, returnSentences?: boolean): Promise<ER.Analytics.Response.Sentiment>;
    semanticSimilarity(text1: string, text2: string, distanceMeasure?: "cosine" | "jaccard"): Promise<ER.Analytics.Response.SentimentSimilarity>;
    /**
     * Determine the language of the given text
     * @param text input text to analyse
     */
    detectLanguage(text: string): Promise<ER.Analytics.Response.DetectLanguage>;
    /**
     * Extract all available information about an article available at url `url`.
     * Returned information will include article title, body, authors, links in the articles,...
     * @param url article url that'll be used for extraction
     * @param proxyUrl proxy that should be used for downloading article information. format: {schema}://{username}:{pass}@{proxy url/ip}
     */
    extractArticleInfo(url: string, proxyUrl?: string, headers?: {
        [name: string]: unknown;
    }, cookies?: {
        [name: string]: unknown;
    }): Promise<ER.Analytics.Response.ExtractArticleInfo>;
    /**
     * Extract named entities from the provided text. Supported languages are English, German, Spanish and Chinese.
     * @param text: text on which to extract named entities
     */
    ner(text: string): Promise<unknown>;
    /**
     * Create a new topic and train it using the tweets that match the twitterQuery
     * @param twitterQuery string containing the content to search for. It can be a Twitter user account (using "@" prefix or user's Twitter url),a hash tag (using "#" prefix) or a regular keyword.
     * @param args Object which contains a host of optional parameters
     */
    trainTopicOnTweets(twitterQuery: string, args?: ER.Analytics.TrainTopicOnTweetsArguments): Promise<ER.Analytics.Response>;
    /**
     * Create a new topic to train. The user should remember the "uri" parameter returned in the result.
     * @param name name of the topic we want to create
     * @returns object containing the "uri" property that should be used in the follow-up call to trainTopic* methods
     */
    trainTopicCreateTopic(name: string): Promise<ER.Analytics.Response>;
    /**
     * If the topic is already existing, clear the definition of the topic. Use this if you want to retrain an existing topic
     * @param uri uri of the topic (obtained by calling trainTopicCreateTopic method) to clear
     */
    trainTopicClearTopic(uri: string): Promise<ER.Analytics.Response>;
    /**
     * Add the information extracted from the provided "text" to the topic with uri "uri".
     * @param uri uri of the topic (obtained by calling trainTopicCreateTopic method)
     * @param text text to analyze and extract information from
     */
    trainTopicAddDocument(uri: string, text: string): Promise<ER.Analytics.Response>;
    /**
     * Retrieve topic for the topic for which you have already finished training
     * @param uri uri of the topic (obtained by calling trainTopicCreateTopic method)
     * @returns returns the trained topic: { concepts: [], categories: [] }
     */
    trainTopicGetTrainedTopic(uri: string, args?: ER.Analytics.TrainTopicGetTrainedTopicArguments): Promise<ER.Analytics.Response>;
}
